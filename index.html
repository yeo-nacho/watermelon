<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>ì—°ì•„ì˜ ìˆ˜ë°•ê²Œì„</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Mooli&display=swap" rel="stylesheet">
    <style>
        /* ê¸°ë³¸ í˜ì´ì§€ ë° í°íŠ¸ ì„¤ì • */
        body {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            height: 100vh;
            margin: 0;
            background: linear-gradient(to top, #a1c4fd 0%, #c2e9fb 100%);
            font-family: 'Mooli', sans-serif;
            overflow: hidden;
        }

        h1 {
            font-size: 3em;
            color: #fff;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
        }

        /* ë°˜ì‘í˜• ìŠ¤ì¼€ì¼ë§ì„ ìœ„í•œ ë˜í¼ */
        #game-wrapper {
            display: flex;
            justify-content: center;
            align-items: center;
        }

        /* ê²Œì„ì˜ ëª¨ë“  ìš”ì†Œê°€ ë‹´ê¸°ëŠ” ë©”ì¸ ì»¨í…Œì´ë„ˆ */
        #game-container { 
            position: relative; 
            border: 10px solid #8B4513; 
            border-radius: 20px; 
            box-shadow: 0 10px 20px rgba(0,0,0,0.3);
            transform-origin: top center; /* ìŠ¤ì¼€ì¼ë§ ê¸°ì¤€ì  */
        }

        canvas {
            border-radius: 10px;
            display: block; /* ìº”ë²„ìŠ¤ ì•„ë˜ ì‘ì€ ì—¬ë°± ì œê±° */
        }

        /* ê²Œì„ ë‚´ UI ìš”ì†Œ ìŠ¤íƒ€ì¼ */
        #score {
            position: absolute;
            top: 15px;
            left: 20px;
            font-size: 28px;
            font-weight: bold;
            color: #fff;
            text-shadow: 2px 2px 3px #555;
            z-index: 10;
        }

        #mute-button {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 40px;
            height: 40px;
            font-size: 24px;
            background: rgba(255, 255, 255, 0.5);
            border: none;
            border-radius: 50%;
            cursor: pointer;
            z-index: 10;
        }

        /* ê²Œì„ ì˜¤ë²„ í™”ë©´ */
        #game-over-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            display: none; /* í‰ì†Œì—ëŠ” ìˆ¨ê¹€ */
            justify-content: center;
            align-items: center;
            flex-direction: column;
            z-index: 15;
            border-radius: 10px;
        }

        #game-over-text {
            font-size: 48px;
            font-weight: bold;
            color: white;
            margin-bottom: 20px;
        }

        #restart-button {
            padding: 15px 30px;
            font-size: 24px;
            font-family: 'Mooli', sans-serif;
            font-weight: bold;
            color: #4B0082;
            background-color: #fff;
            border: 3px solid #ddd;
            border-radius: 10px;
            cursor: pointer;
        }
    </style>
</head>
<body>
    <audio id="bgm" loop src="music/bgm.mp3"></audio>

    <h1>ì—°ì•„ì˜ ìˆ˜ë°•ê²Œì„</h1>

    <div id="game-wrapper">
        <div id="game-container">
            <canvas id="game-canvas"></canvas>
            <div id="score">ì ìˆ˜: 0</div>
            <button id="mute-button">ğŸ”‡</button>
            <div id="game-over-screen">
                <div id="game-over-text">ê²Œì„ ì˜¤ë²„</div>
                <button id="restart-button">ë‹¤ì‹œ ì‹œì‘í•˜ê¸°</button>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <script>
        // --------------------------------------------------
        // 1. ìƒìˆ˜ ì„ ì–¸
        // --------------------------------------------------
        const { Engine, Render, Runner, World, Bodies, Body, Events, Composite, Sleeping } = Matter;
        const WIDTH = 600, HEIGHT = 750, WALL_THICKNESS = 50, GAME_OVER_LINE = 120;
        const DROP_SOUND_URL = 'music/drop.mp3';
        const MERGE_SOUND_URL = 'music/pop.mp3';
        const FRUITS_DATA = [
            { level: 0, radius: 20, score: 1, imgSrc: 'img/00_cherry.png' }, { level: 1, radius: 25, score: 3, imgSrc: 'img/01_strawberry.png' }, { level: 2, radius: 35, score: 6, imgSrc: 'img/02_grape.png' }, { level: 3, radius: 40, score: 10, imgSrc: 'img/03_gyool.png' }, { level: 4, radius: 50, score: 15, imgSrc: 'img/04_orange.png' }, { level: 5, radius: 60, score: 21, imgSrc: 'img/05_apple.png' }, { level: 6, radius: 70, score: 28, imgSrc: 'img/06_pear.png' }, { level: 7, radius: 80, score: 36, imgSrc: 'img/07_peach.png' }, { level: 8, radius: 90, score: 45, imgSrc: 'img/08_pineapple.png' }, { level: 9, radius: 100, score: 55, imgSrc: 'img/09_melon.png' }, { level: 10, radius: 110, score: 66, imgSrc: 'img/10_watermelon.png' },
        ];

        // --------------------------------------------------
        // 2. ê²Œì„ í´ë˜ìŠ¤ ì •ì˜
        // --------------------------------------------------
        class SuikaGame {
            constructor() {
                // DOM ìš”ì†Œ
                this.container = document.getElementById('game-container');
                this.canvas = document.getElementById('game-canvas');
                this.scoreElement = document.getElementById('score');
                this.gameOverScreen = document.getElementById('game-over-screen');
                this.restartButton = document.getElementById('restart-button');
                this.bgm = document.getElementById('bgm');
                this.muteButton = document.getElementById('mute-button');
                
                // ê²Œì„ ìƒíƒœ
                this.engine = null; this.world = null; this.render = null; this.runner = null;
                this.score = 0; this.currentFruit = null; this.disableAction = false;
                this.gameOver = false; this.isMusicStarted = false; this.scale = 1;
                this.loadedImages = [];
            }

            /**
             * ê²Œì„ ê³µê°œ ì§„ì…ì : ì´ë¯¸ì§€ ë¡œë”© í›„ ê²Œì„ ì‹œì‘
             */
            init() {
                let loadedCount = 0;
                FRUITS_DATA.forEach((fruit, index) => {
                    const img = new Image();
                    img.src = fruit.imgSrc;
                    img.onload = () => {
                        loadedCount++;
                        if (loadedCount === FRUITS_DATA.length) this._startGame();
                    };
                    img.onerror = () => {
                        console.error(`ì´ë¯¸ì§€ ë¡œë”© ì‹¤íŒ¨: ${fruit.imgSrc}`);
                        loadedCount++;
                        if (loadedCount === FRUITS_DATA.length) this._startGame();
                    };
                    this.loadedImages[index] = img;
                });
            }
            
            /**
             * ì‹¤ì œ ê²Œì„ ì‹œì‘ ë¡œì§ (ë‚´ë¶€ìš©)
             */
            _startGame() {
                this.engine = Engine.create();
                this.world = this.engine.world;
                this.render = Render.create({ canvas: this.canvas, engine: this.engine, options: { width: WIDTH, height: HEIGHT, wireframes: false, background: '#F0EAD6' } });
                this.runner = Runner.create();
                
                const wallOptions = { isStatic: true, render: { fillStyle: '#A0522D' } };
                World.add(this.world, [
                    Bodies.rectangle(WIDTH / 2, HEIGHT - WALL_THICKNESS / 2, WIDTH, WALL_THICKNESS, wallOptions),
                    Bodies.rectangle(WALL_THICKNESS / 2, HEIGHT / 2, WALL_THICKNESS, HEIGHT, wallOptions),
                    Bodies.rectangle(WIDTH - WALL_THICKNESS / 2, HEIGHT / 2, WALL_THICKNESS, HEIGHT, wallOptions),
                ]);

                Render.run(this.render);
                Runner.run(this.runner, this.engine);
                
                this._addEventListeners();
                this._addNewIndicatorFruit();
                this._resizeGame();
            }

            /**
             * ê²Œì„ ì¬ì‹œì‘ ë¡œì§ (ë‚´ë¶€ìš©)
             */
            _restartGame() {
                Runner.stop(this.runner);
                Render.stop(this.render);
                World.clear(this.world);
                Engine.clear(this.engine);

                this.score = 0; this.gameOver = false; this.disableAction = false; this.currentFruit = null;
                this._updateScore();
                this.gameOverScreen.style.display = 'none';

                this._startGame();
            }

            /**
             * ëª¨ë“  ì´ë²¤íŠ¸ ë¦¬ìŠ¤ë„ˆ í†µí•© ê´€ë¦¬ (ë‚´ë¶€ìš©)
             */
            _addEventListeners() {
                window.onresize = () => this._resizeGame();
                this.restartButton.onclick = () => this._restartGame();
                this.muteButton.onclick = () => {
                    this.bgm.muted = !this.bgm.muted;
                    this.muteButton.textContent = this.bgm.muted ? 'ğŸ”‡' : 'ğŸµ';
                };
                
                const handleMove = (event) => {
                    if (!this.currentFruit || !this.currentFruit.isSleeping || this.gameOver) return;
                    const clientX = event.type.includes('touch') ? event.touches[0].clientX : event.clientX;
                    const bounds = this.canvas.getBoundingClientRect();
                    const correctedX = (clientX - bounds.left) / this.scale;
                    const fruitData = FRUITS_DATA[this.currentFruit.level];
                    const newX = Math.max(
                        WALL_THICKNESS + fruitData.radius,
                        Math.min(correctedX, WIDTH - WALL_THICKNESS - fruitData.radius)
                    );
                    Body.setPosition(this.currentFruit, { x: newX, y: this.currentFruit.position.y });
                };
                this.canvas.onclick = () => { if (!this.gameOver) this._dropCurrentFruit(); };
                this.canvas.onmousemove = handleMove;
                this.canvas.ontouchmove = handleMove;

                Events.on(this.engine, 'collisionStart', (event) => this._handleCollision(event));
                Events.on(this.engine, 'beforeUpdate', () => this._checkGameOver());
                Events.on(this.render, 'afterRender', () => this._drawCustomElements());
            }

            /**
             * ë°˜ì‘í˜• ë””ìì¸ì„ ìœ„í•œ ê²Œì„ í¬ê¸° ì¡°ì ˆ (ë‚´ë¶€ìš©)
             */
            _resizeGame() {
                const wrapper = document.getElementById('game-wrapper');
                const scale = Math.min(wrapper.clientWidth / WIDTH, wrapper.clientHeight / HEIGHT);
                this.scale = scale;
                this.container.style.transform = `scale(${scale})`;
            }

            /**
             * ì¶©ëŒ ì²˜ë¦¬ ë¡œì§ (ë‚´ë¶€ìš©)
             */
            _handleCollision(event) {
                event.pairs.forEach((pair) => {
                    const { bodyA, bodyB } = pair;
                    if (bodyA.label === 'fruit' && bodyB.label === 'fruit' && bodyA.level === bodyB.level) {
                        const currentLevel = bodyA.level;
                        if (currentLevel >= FRUITS_DATA.length - 1 || !this.world.bodies.includes(bodyA) || !this.world.bodies.includes(bodyB)) return;
                        
                        this._playSoundEffect(MERGE_SOUND_URL);
                        const midX = (bodyA.position.x + bodyB.position.x) / 2;
                        const midY = (bodyA.position.y + bodyB.position.y) / 2;
                        World.remove(this.world, [bodyA, bodyB]);
                        
                        this.score += FRUITS_DATA[currentLevel].score;
                        this._updateScore();

                        setTimeout(() => {
                            const newFruit = this._createFruitBody(midX, midY, currentLevel + 1, false);
                            World.add(this.world, newFruit);
                        }, 50);
                    }
                });
            }

            /**
             * ê²Œì„ ì˜¤ë²„ ì¡°ê±´ ì²´í¬ (ë‚´ë¶€ìš©)
             */
            _checkGameOver() {
                if (this.gameOver) return;
                for (const body of Composite.allBodies(this.world)) {
                    if (body.label === 'fruit' && body.position.y - body.circleRadius < GAME_OVER_LINE) {
                        body.framesAboveLine = (body.framesAboveLine || 0) + 1;
                        if (body.framesAboveLine > 60 * 1.5) {
                            this._endGame();
                            return;
                        }
                    } else if (body.framesAboveLine) {
                        body.framesAboveLine = 0;
                    }
                }
            }

            /**
             * ê³¼ì¼ ì´ë¯¸ì§€ì™€ ê²Œì„ì˜¤ë²„ ë¼ì¸ ê·¸ë¦¬ê¸° (ë‚´ë¶€ìš©)
             */
            _drawCustomElements() {
                const context = this.render.context;
                Composite.allBodies(this.world).forEach(body => {
                    if (body.label.startsWith('fruit')) {
                        const img = this.loadedImages[body.level];
                        if (img && img.complete) {
                            const { x, y } = body.position;
                            const angle = body.angle;
                            const radius = body.circleRadius;
                            context.save();
                            context.translate(x, y);
                            context.rotate(angle);
                            context.drawImage(img, -radius, -radius, radius * 2, radius * 2);
                            context.restore();
                        }
                    }
                });
                context.beginPath();
                context.moveTo(WALL_THICKNESS, GAME_OVER_LINE);
                context.lineTo(WIDTH - WALL_THICKNESS, GAME_OVER_LINE);
                context.strokeStyle = 'rgba(212, 2, 2, 0.5)';
                context.lineWidth = 4;
                context.setLineDash([10, 10]);
                context.stroke();
                context.setLineDash([]);
            }

            /**
             * ê³¼ì¼ ë¬¼ë¦¬ ê°ì²´ ìƒì„± (ë‚´ë¶€ìš©)
             */
            _createFruitBody(x, y, level, isSleeping) {
                const fruitData = FRUITS_DATA[level];
                return Bodies.circle(x, y, fruitData.radius, { isSleeping, label: isSleeping ? 'fruit_indicator' : 'fruit', level, restitution: 0.2, friction: 0.5, render: { visible: false } });
            }
            
            /**
             * ë‹¤ìŒ ê³¼ì¼ ì¤€ë¹„ (ë‚´ë¶€ìš©)
             */
            _addNewIndicatorFruit() {
                const level = Math.floor(Math.random() * 5);
                this.currentFruit = this._createFruitBody(WIDTH / 2, 50, level, true);
                World.add(this.world, this.currentFruit);
            }

            /**
             * í˜„ì¬ ê³¼ì¼ ë–¨ì–´ëœ¨ë¦¬ê¸° (ë‚´ë¶€ìš©)
             */
            _dropCurrentFruit() {
                if (!this.currentFruit || this.disableAction) return;

                if (!this.isMusicStarted) {
                    this.bgm.volume = 0.2;
                    this.bgm.play().catch(e => console.error("BGM ì¬ìƒ ì‹¤íŒ¨", e));
                    this.isMusicStarted = true;
                    this.muteButton.textContent = 'ğŸµ';
                }
                
                this._playSoundEffect(DROP_SOUND_URL);
                this.disableAction = true;
                Sleeping.set(this.currentFruit, false);
                this.currentFruit.label = 'fruit';
                this.currentFruit = null;
                setTimeout(() => {
                    this._addNewIndicatorFruit();
                    this.disableAction = false;
                }, 600);
            }
            
            /**
             * íš¨ê³¼ìŒ ì¬ìƒ (ë‚´ë¶€ìš©)
             */
            _playSoundEffect(url) {
                const sound = new Audio(url);
                sound.volume = 0.4;
                sound.play().catch(e => console.error("íš¨ê³¼ìŒ ì¬ìƒ ì‹¤íŒ¨", e));
            }

            /**
             * ì ìˆ˜ UI ì—…ë°ì´íŠ¸ (ë‚´ë¶€ìš©)
             */
            _updateScore() {
                this.scoreElement.innerText = `ì ìˆ˜: ${this.score}`;
            }

            /**
             * ê²Œì„ ì¢…ë£Œ ì²˜ë¦¬ (ë‚´ë¶€ìš©)
             */
            _endGame() {
                if (this.gameOver) return;
                this.gameOver = true;
                this.gameOverScreen.style.display = 'flex';
                Runner.stop(this.runner);
            }
        }

        // --------------------------------------------------
        // 3. ê²Œì„ ì¸ìŠ¤í„´ìŠ¤ ìƒì„± ë° ì‹œì‘
        // --------------------------------------------------
        window.onload = () => {
            const game = new SuikaGame();
            game.init();
        };
    </script>
</body>
</html>
